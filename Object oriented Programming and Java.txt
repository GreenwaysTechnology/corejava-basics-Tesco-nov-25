									Object oriented Programming and Java

What is Object orientation?
	It is one of the programming paradigms.
       Paradigms are styles or approaches to programming that define how code is structured, written, and executed

		They guide how developers think about problems and how programs should be organized

Major Programming paradigms:

1.Imperative Programming
	Tell the computer how to do things step by step
c,java,js
2.Procedural programming (Subset of imperative)
	organizes the code into procedures or functions
languages which follows procedural programming is
  c, pascal, FORTRAN
3.Object oriented programming 
	organizes the code into classes and objects
  object/class consist of data + behavior
  eg: c++,java,C# etc...
4.Functional Programming
	organizes the code based on functions not state(data)
  eg: javascript, java
etc....

&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
									Object orientation 
Focus:
  Organize the code into classes and objects.
  code means
	-having data (state) - variables
	-having behavior (methods) - which change /mutate the data

 object/class = {
	state + behavior
} 

	any programming paradigm has set of principles, based on those principles only language works

Principles of Object orientation:

Grady Booch principles:

1.Abstraction
2.Encapsulation
3.Modularity
4.Hierarchy
5.Typing
******************************** Required 
6.Concurrency
7.Persistency

		 if any language follows the first 5 principles the language called as "Object oriented Programming language"

We are going to talk about each principle what it is? and how it can be implemented?

1.Abstraction:
	Take necessary information from the real world object eg: know about basic information about car what you are driving 	

Principles of abstraction:
1.focus on essential characteristics
2.Ignore unnecessary details
3.Model things based what they do, not how they work internally.
		if you start car without knowing how the engine internally ignites.

How to apply abstraction in software system?
  
For eg, if you are designing banking system, you want capture various information.
In banking system, who is primary actor?
	Customer 
Customer is just human being, Human being is associated with "millions of properties" eg 
           : age,dob,gender,height,wieght,skin color,address,name,etc....

if you represent human being in banking system, what information you capture as customer

1.name - firstname,lastname,middlename
2.address
3.adhar card/ssn
4.PAN
5.dob
6.age
7.mobile no
8.email id
9.type of account
etc.....

How to implement abstraction in java?

	class
what is class?
	In general, Class is a container which captures necessary information about "real time entity /object/thing"
	class = {
		information about customer, patient, Employee, Passenger
	}
     In programming languages , class is "data type" - Custom Data type or Reference Data type
    class contains two things one data + behavior 

	class  = {
		data(state) 
		behavior (methods)
	}

Syntax:
	public  class Customer {}
	public class Patient {}
	public class Employee {}

eg:
public class Customer {
    //state
    int id;
    String name;
    String address;
    String email;
    String phoneNo;
    String SSN;
    double amount;
    String accountType;
}

Object:
			According to Booch, "An Object is a thing, both tangible and intangible, that has state, behavior, and identity"
								Object could be any thing but that should be related  to the Problem Domain

According to java, Object is the implementation of class.

Where as class is blue print, Object is implementation.

Class is Going to capture state and its behavior, Object is going to allocate memory during runtime

					class is compile time thing , where as object is runtime thing.

Object Creation Syntax:

	Type variable = new ClassName() /ConstructorCall()

					Operator - Memory Allocation Operator
						|		
	ClassName variable = new ClassName() -Memory allocated for this blue print
		|              |
	Reference Type	     Reference variable

public class CustomerMain {
    public static void main(String[] args) {
        //create instance/object from the class
        Customer customer = new Customer();
        
    }
}
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
										 State Representation and Process
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

State means data
Data is encapsulated inside variables 
variables are subject to change
Some variable's value change over period of time , some variable's value may not change
for age , value changes every year, but dob may not change.

		if any variable is declared inside "class" those variables are called as "Instance Variables"

Variables category:

Based on data type:
1.Primitive variables 
		variables declared with primitive data type
	int a, float b, char c
2.Reference variables
	 Customer customer,Order order,Address address;

Based on Declarations:
1.instance variables
	any variable with any type , declared with in class 
class Customer {
	int id ;  // This is instance variable ; This is "instance primitive variable"
	Address address; // This is instance variable ; This is "instance Reference variable"
}
2.local variables
	any variables are declared within "method" with any type called local variable

public static void main(String[] args) {
        //create instance/object from the class
        Customer customer = new Customer(); //local variable ;  local reference variable
	int a=10; //local variables; local primitive   variable 

    }
3.static variables
	To be discussed later.

.........................................................................................................................................................................................................................................
										 State(instance variable initialization)


There are different ways we can initialize the instance variables

1.inside class directly 
2.outside the class directly - during runtime , using object references
3.inside class via constructors - during runtime
4.outside the class via "some special methods"

1.inside class directly 
public class Customer {
    //instance variables - state
    int id = 1;
    String name = "Subramanian Murugan";
    String address = "Coimbatore, Tamil Nadu, India";
    String email = "sasubramanian_md@hotmail.com";
    String phoneNo = "9003706368";
    String SSN = "232323232323132213";
    double amount = 1000000;
    String accountType = "Current Account";
}

How to access the  instance variables outside class
>You have to create object/instance
>You have to access the instance variables via "Reference variables" only.

referencevariable.instancevariable
public class CustomerMain {
    public static void main(String[] args) {
        //create instance/object from the class
        Customer customer = new Customer();
        System.out.println("Id :" + customer.id);
        System.out.println("Name :" + customer.name);
        System.out.println("Address :" + customer.address);
        System.out.println("Email :" + customer.email);
        System.out.println("Phone  :" + customer.phoneNo);
        System.out.println("SSN :" + customer.SSN);
        System.out.println("Amount :" + customer.amount);
        System.out.println("Account Type :" + customer.accountType);

    }
}
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
								2.outside the class directly - during runtime , using object references


public class Employee {
    int id;
    String name;
    double salary;
}

public class EmployeeMain {
    public static void main(String[] args) {
        Employee employee = new Employee();
        System.out.println("Id :" + employee.id);
        System.out.println("Name :" + employee.name);
        System.out.println("Salary : " + employee.salary);
    }
}
output:
Id :0
Name :null
Salary : 0.0

here you can note down, we have not initialized the values explicitly , but java has given some value which are called "default values"

Default values for instance variable:
 default values are assigned by java during runtime based on the type of variable

byte,int,long,short - 0
float,double =0.0
char = some unicode char
boolean =false

Reference Types:
 Any reference type default value would be  "null"


public class EmployeeMain {
    public static void main(String[] args) {
        Employee employee = new Employee();

        employee.id=10;
        employee.name="Subramnaian Murugan";
        employee.salary=2000;
        employee.gender='M';
        employee.isActive=true;

        System.out.println("Id :" + employee.id);
        System.out.println("Name :" + employee.name);
        System.out.println("Salary : " + employee.salary);
        System.out.println("Gender : " + employee.gender);
        System.out.println("Status : " + employee.isActive);

    }
}
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
										 methods(behavior) 
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

What is method?
	A method is a block of code inside class that performs an action.
eg:
startEngine(),depositMoney(),getMarks(),calculateSalary()

Syntax:
 accessModifier   returnType methodName(args){
    //code to be executed
 }
public class Car {
    //state
    String name;
    int speed;

    //behaviour //methods
    void start() {
        System.out.println(name + " Started");
    }

    void acclerate(int increment) {
        speed += increment;
        System.out.println("Speed is now : " + speed);
    }

    void stop() {
        speed = 0;
        System.out.println(name + " Stopped");
    }
}
public class CarMain {
    public static void main(String[] args) {
        Car car = new Car();
        car.name = "BMW";
        car.start();
        //4 parameter
        car.acclerate(4);
        car.acclerate(4);

        car.stop();

    }
}

Lab:
1.Employee Salary Calculation
Attributes/state: id,name,basicSalary
methods:
  calculateHRA() -> 20% Of basic
  calculatePF() -> 10% OF Basic
  calculateNetSalary =  basic+ HRA-PF
  displaySalary

2.Temperature Converter
celsiusToFahrenheit  - double c
 fahrenheitToCelsisus - double f

F =  C * 9/5 + 32
C=(F-32) * 5/9

3.Electricity Bill Generator
 attributes: consumerName, units
methods: calculateBill

Rules:
 First 100 unit = 5 /unit
 Next 100 units = 7 / unit
Above 200 units = 10 / unit

&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
								    			Encapsulation 
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

Encapsulation means wrapping data(variables) and actions (methods) into a single unit -  a class-- and restricting direct access to some components
									  Who can see and who can access

			 							 "Preventing code sharing"

code is represented into classes which contains data and methods.
how classes are organized , classes are organized into folders which is called packages in java

	In Real time applications, you write more number of classes, all classes someway  have to be organized 
		
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
										Modularity 

How to organize /modularize the code?
		packages

What is package ?
  package is a folder-like structure used to group related classes, interfaces, and sub packages

Packages help to :
organize the code
Avoid class name conflict 
Provide access control
Reuse classes easily

Note:
 Every java project has to be organized with help of packages only.


syntax:
   org.organizationName.projectname.subproject ..
   com.companyName.projectname.subproject ....
   java.projectname.subproject
   javax.projectname.subject

Types of packages:
1.built in packages
	 packages which are part of the language
	 built in packages starts with java. or javax 
	 built in package name cant be used by us for our own packages

	java.lang -  basic classes related to language
	java.util - datastructure
	java.io -  input and output
	java.net - networking
	java.sql - database

2.Custom packages
	packages what we create
	eg:
	 " com.tesco.banking.loan.housing"
3.Third packages
	packages which are distributed by "thrid parties"
	frameworks,libs
	for eg: spring,apache camel,log4ji

how to create package and how to use the package

package com.tesco.banking;

how to use package?
import com.tesco.banking.className;


eg:
package com.tesco.hr;

public class Employee {
    int id;
    String name;
}
package com.tesco.hr.app;

import com.tesco.hr.Employee;

public class HRMain {
    public static void main(String[] args) {
        Employee employee = new Employee();
        //employee.id=1;

    }
}
here you cant access id why? will discuss


package com.tesco.hr;

public class EmployeeAppMain {
    public static void main(String[] args) {
        Employee employee = new Employee();
        employee.id=1;
    }
}
here you can access id ? why
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
								    Encapsulations Implementation

Via access modifiers:

java provides 4 access modifiers

1.public 
2.private
3.default -no keyword
4.protected 

these keywords are applied on classes, instance variables, methods

public:
 can be applied on classes,variables,methods
public means , if you declare any thing public.
you can access any where in the app, you can access outside the current package
public class Customer{}

public class Customer {
	public int id;
}
public class Car {
Â    public void start(){}
}

eg:
package com.tesco.hr;

public class Employee {
    public int id;
    public String name;
}

eg:
package com.tesco.transport;

public class Car {
    //state
    public String name;
    public int speed;

    //behaviour //methods
    public void start() {
        System.out.println(name + " Started");
    }

    public void acclerate(int increment) {
        speed += increment;
        System.out.println("Speed is now : " + speed);
    }

    public void stop() {
        speed = 0;
        System.out.println(name + " Stopped");
    }
}
package com.google.app;

import com.tesco.transport.Car;

public class CarMain {
    public static void main(String[] args) {
        Car car = new Car();
        car.name = "BMW";
        car.start();
        car.acclerate(3);
        car.stop();


    }
}
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
									      private
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

if you declare private, that is not accessible outside the class

private cant be applied on classes.

private
 ->variables
-> methods
->constructors

package com.tesco.privatedemo;

public class User {
    private int id;
    private String userName;
    private String email;
    private String password;
}
package com.tesco.privatedemo;

public class UserMain {
    public static void main(String[] args) {
        User user = new User();
//        user.id;
//        user.auth
                
    }
}
Here id and auth method not available outside the class, because it is private...
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
							 private variables and coding standard
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

Common java coding Standard:
....................................................

FileName:
->File Name must be Noun
	Employee.java
->First Letter must be capital case
->FileName and class name should be same ,it can be different
	if class is declared public , filename and class must be same 

className:
->ClassName must be noun always
	eg:Emplolyee,Customer
->It should start with capital case
->if there is two nouns,the second noun must start with uppercase 
		LoginService,EmployeeManager,LoginController,LoginDto
->Most of the time, class must have "public" modifier, some times class maynot have any modifier - default modifer

instance variables:
 ->variables names must be noun, 
->it should start with camel case,
->Variables  must be meaningful to the domain
->Variables must start with smaller
->"All instance variables must have private modifier",
->"Instance variables mostly not to mark public"
eg:
	private int employeeId;	
	private String firstName;
	private String salary;

methods (instance and static methods)
1.instance methods must be verb+noun or verb
2.method must start with smaller case
	start(),startEngine(),setX,getY
3.method may return values or may not -void
4.methods may take args
5.method can return any type from primitives to references types
6.methods can be marked "private /public /protected /no keyword(default)"

package com.tesco.methods;

public class Account {

    public void deposit(double amount) {
        System.out.println(amount);
    }

    private double withdraw() {
        return 10.8;
    }

    double calculate(double input) {
        return input * 4.5;
    }

}

Types of methods:

based on declaration
1.instance methods
2.class methods/static methods

based on usage
1.accessor and mutator methods
	special methods which are called as "setters and getters"
	used to initialize  the state variables and read state variables

Since instance variables are private, we need these setters and getters for accessing data.

setter Syntax:
 all setters must be public
 all setters must be void return type
 method must start with "setVariableName"
 method must have arg with same name and same type of instance variable
 variable must be initialized via "this" key word
   private int id;
   public 	void setId(int id){
	 this.id =id
   }
  Each instance variable must have its own setters.
eg:
package com.tesco.privatedemo;

public class User {
    private int id;
    private String userName;
    private String email;
    private String password;

    public void setId(int id) {
        this.id = id;
    }

    public void setUserName(String userName) {
        this.userName = userName;
    }

    public void setEmail(String email) {
        this.email = email;
    }

    public void setPassword(String password) {
        this.password = password;
    }

    private void auth() {
        System.out.println("auth");
    }
}
getters
->getters also must be public 
->getters must have return type of what variable you return 
->getters must start with "getVariable"
->getters must not have any args
->it should return instance variable
public int getId(){
	return id
}
package com.tesco.privatedemo;

public class User {
    private int id;
    private String userName;
    private String email;
    private String password;

    public void setId(int id) {
        this.id = id;
    }

    public void setUserName(String userName) {
        this.userName = userName;
    }

    public void setEmail(String email) {
        this.email = email;
    }

    public void setPassword(String password) {
        this.password = password;
    }

    public int getId() {
        return id;
    }

    public String getUserName() {
        return userName;
    }

    public String getEmail() {
        return email;
    }

    public String getPassword() {
        return password;
    }

    private void auth() {
        System.out.println("auth");
    }
}
package com.tesco.privatedemo;

public class UserMain {
    public static void main(String[] args) {
        User user = new User();
        user.setId(1);
        user.setUserName("admin");
        user.setEmail("admin@tesco.com");
        user.setPassword("admin");
        //i
        System.out.println(user.getId());
        System.out.println(user.getUserName());
        System.out.println(user.getEmail());
        System.out.println(user.getPassword());
//        user.id;
//        user.auth

    }
}

2.biz methods

 methods which does some state processing

deposit(),withdraw,start etc....

&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
									3.default -no keyword
you can declare any thing as default...
class,instance variables,methods,constructors

class Customer{} - default class
class Customer { 
	int id; //default instance variable
}
class LoginService{
	
    boolean login(){} //default instance methods
}

if any thing is declared as default which is available inside the same package only

package com.tesco.hr;

public class Employee {
    int id;
    String name;
}
package com.tesco.hr.app;

import com.tesco.hr.Employee;

public class HRMain {
    public static void main(String[] args) {
        Employee employee = new Employee();
        //employee.id=1;

    }
}
here you cant access id why? because default scope


package com.tesco.hr;

public class EmployeeAppMain {
    public static void main(String[] args) {
        Employee employee = new Employee();
        employee.id=1;
    }
}
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
										Hierarchy
									Order of Abstractions

 "Objects and classes  should be organized into hierarchies to manage complexity using abstraction, generalization, and decomposition"

Types of Hierarchies:
....................................

1.class Hierarchy / IS-A Hierarchy:
	This hierarchy is built using "generalization/specialization".
How to implement?
	 In programming languages, class hierarchies are called as "inheritance"
characteristics:
1.parent and child relationships
2.Reuse attributes and Behaviours
3.Polymorphism

2.Object Hierarchy (Aggregation/Composition)
   This hierarchy shows whole-part relationships (HAS-a relationship)
  Object has another Object
	eg:
	Car has Engine
class vs object hierarchy:
	class is compile time hierarchy where as object is runtime hierarchy
		"The relationship between classes are decided during compile time and object relationship is decided during runtime"

3.Module Hierarchy
		Grouping related classes into single unit - packages/components

&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
										Class Hierarchy implementation - inheritance
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

Why inheritance?
	code reuse or avoid code duplication

Java and inheritance implementation:

1.concrete class inheritance
2.interface based inheritance
3.abstract class based inheritance


1.concrete class inheritance:

 how to share code between or among classes 

eg:
 Car
 Bike
 Truck

common properties in all Vehicle
 brand
 speed

Without Inheritance, how the state /variables are duplicated:
package com.tesco.inheritance;

public class Car {
    private String brand;
    private int speed;

    public String getBrand() {
        return brand;
    }

    public void setBrand(String brand) {
        this.brand = brand;
    }

    public int getSpeed() {
        return speed;
    }

    public void setSpeed(int speed) {
        this.speed = speed;
    }
}
package com.tesco.inheritance;

public class Truck {
    private String brand;
    private int speed;

    public String getBrand() {
        return brand;
    }

    public void setBrand(String brand) {
        this.brand = brand;
    }

    public int getSpeed() {
        return speed;
    }

    public void setSpeed(int speed) {
        this.speed = speed;
    }
}

package com.tesco.inheritance;

public class Bike {
    private String brand;
    private int speed;

    public String getBrand() {
        return brand;
    }

    public void setBrand(String brand) {
        this.brand = brand;
    }

    public int getSpeed() {
        return speed;
    }

    public void setSpeed(int speed) {
        this.speed = speed;
    }
}

Here you can notice , variables are duplicated.
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
									 Inheritance and code Reuse

You can create common class, have common properties which can be connected with classes where you want to share properties.


package com.tesco.inheritance;

//car class now connected with vehicle class
//all vechile properties are shared to car, so cant need not declare properties again
//car is child class and where as Vehicle is parent class
public class Car extends Vehicle {
    
}

eg:
package com.tesco.inheritance;

public class Vehicle {
    private String brand;
    private int speed;

    public String getBrand() {
        return brand;
    }

    public void setBrand(String brand) {
        this.brand = brand;
    }

    public int getSpeed() {
        return speed;
    }

    public void setSpeed(int speed) {
        this.speed = speed;
    }
}
package com.tesco.inheritance;

//car class now connected with vehicle class
//all vechile properties are shared to car, so cant need not declare properties again
//car is child class and where as Vehicle is parent class
public class Car extends Vehicle {
    private int doors;

    public int getDoors() {
        return doors;
    }

    public void setDoors(int doors) {
        this.doors = doors;
    }
}
package com.tesco.inheritance;

public class Truck extends Vehicle {
     private int loadCapacity;

    public int getLoadCapacity() {
        return loadCapacity;
    }

    public void setLoadCapacity(int loadCapacity) {
        this.loadCapacity = loadCapacity;
    }
}
package com.tesco.inheritance;

public class Bike extends Vehicle {

}
package com.tesco.inheritance;

public class VehicleMain {
    public static void main(String[] args) {
        Car car = new Car();
        car.setBrand("BMW");
        car.setSpeed(33);
        car.setDoors(4);
        System.out.println(car.getBrand());
        System.out.println(car.getSpeed());
        System.out.println(car.getDoors());

        //Truck
        Truck truck = new Truck();
        truck.setBrand("Tata");
        truck.setSpeed(180);
        truck.setLoadCapacity(5000);
        System.out.println(truck.getBrand());
        System.out.println(truck.getSpeed());
        System.out.println(truck.getLoadCapacity());

        //Bike
        Bike bike = new Bike();
        bike.setBrand("Hero Honda");
        bike.setSpeed(140);
        System.out.println(bike.getBrand());
        System.out.println(bike.getSpeed());

    }
}

Lab:
1. Employee Payroll system
	
Types of employee:
	1.Contract Employee
	2.Perment Employee
	3.Wage Employee
	4.PartTime Employee
	5.FullTime Employee
You have to identify the common properties among all employees and specific properties in each employee
	Design class hierarchy.

2.Banking system
	Types of account 
	Savings Account
	Current Account
	Loan Account
	Demat Account
You have to identify the common properties among all accounts and specific properties in each Account
	Design class hierarchy.
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
								.Object Hierarchy (Aggregation/Composition)

Object hierarchy is nothing but how objects are connected during runtime.
Has-a relationship:
 	Aggregation represents a "has-a" relationship where the contained objects can exist independently of the container Object.
				 	eg: A Library has Books, but books can exits outside of the Library
		Composition is a stronger "part-of" relationship where the contained objects cant exists without the container.
					eg: A Car has an Engine, if the Car is destroyed , the Engine also destroyed


Composition : Part of Relationship eg:

package com.tesco.oo.partof;

public class Engine {
    private String type;

    public String getType() {
        return type;
    }

    public void setType(String type) {
        this.type = type;
    }
}
package com.tesco.oo.partof;

public class Car {
    private  String model;
    //part of relationship
    private Engine engine;

    public String getModel() {
        return model;
    }

    public void setModel(String model) {
        this.model = model;
    }

    public Engine getEngine() {
        return engine;
    }

    public void setEngine(Engine engine) {
        this.engine = engine;
    }
}
package com.tesco.oo.partof;


public class PartofMain {
    public static void main(String[] args) {
        Engine engine = new Engine();
        engine.setType("BMW Engine");
        Car car = new Car();
        car.setModel("BMW X");
        //binding the object /connecting objects during runtime
        car.setEngine(engine);

        //car details
        System.out.println(car.getModel());
        System.out.println(car.getEngine().getType());

    }
}

Aggregation -has-a
package com.tesco.oo.hasa;

public class Employee {
    private String id;
    private String name;

    public String getId() {
        return id;
    }

    public void setId(String id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}
package com.tesco.oo.hasa;

public class Department {
    private String name;
    //hasa Employee
    private Employee employee;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Employee getEmployee() {
        return employee;
    }

    public void setEmployee(Employee employee) {
        this.employee = employee;
    }
}
package com.tesco.oo.hasa;

public class HasaMain {
    public static void main(String[] args) {
        Employee employee = new Employee();
        employee.setId("1");
        employee.setName("Subramanian");

        Department department = new Department();
        department.setName("Development");
        //binding
        department.setEmployee(employee);

        System.out.println(department.getName() + " => " + department.getEmployee().getName());

    }
}
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
									  	   Typing
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

		"Typing is the enforcement of the class of an object, restricting the kinds of operations that can be applied to it"

Types of Typing

1.Strong typing
	without data type you cant declare any variable
2.Weak typing
	without data type you can declare variables

Java is strongly typed programming language, so the type of variable must be specified.

What if i apply different type?

1.You may get compile time error.

Type conversion:

 Type conversion = changing one data type to another datatype

Java supports two types of conversion

1.implicit conversion / automatic conversion
2.Explicit conversion / Narrowing conversion

1.implicit conversion / automatic conversion
	conversion is taken care by compiler, you dont need to do any conversion manually.

 From smaller data type to larger date type is possible.

byte,short,long,int
float and double

package com.tesco.oo.typeconversion.implicitconversion;

public class AutoMaticConversion {
    public static void main(String[] args) {
        byte b = 10;
        //byte is converted into short automatically
        short s = b;
        System.out.println("B" + b + "S:" + s);
        int i = b;

        //here you get compile  time error; why because 10.5 its type is double by default
        //  float f = 10.5;
        double d = 10.5;
        //        long a = d;
    }
}

Explicit conversion / Narrowing conversion
	 if you try to convert big to small, you will get compile time error, what if i want that conversions
  you can explicitly convert type.
     when you convert, there is possibility of data loss

        int i = 10;
        short s = i;
 here the conversion not possible

syntax
   type variable = (type) variabletobeConverted

package com.tesco.oo.typeconversion.explicitconversion;

public class ExplicitConversion {
    public static void main(String[] args) {
        int i = 10;
        short s = (short) i;
        System.out.println("I" + i + " S " + s);

        float price = (float) 10.5;
        //short cut for float conversion
        float totalPrice = 10.5f;

    }
}
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&										Reference variable conversion


 Employee e = new Employee();
   |               |
Type     reference variable      - type of reference variable is Employee


class Account {}

class SavingsAccount extends Account {}

SavingsAccount sb = new SavingsAccount() 
	
			the type  of "sb"  is SavingsAccount

Program to Super Type:
........................................
Account sb = new SavingsAccount() 
	 The type of sb can be "Super Type"

package com.tesco.oo.typing.referencetype;

public class Account {
}
package com.tesco.oo.typing.referencetype;

public class SavingsAccount extends  Account{
}
package com.tesco.oo.typing.referencetype;

public class ReferenceType {
    public static void main(String[] args) {
        //Program to sub Type
        SavingsAccount sb = new SavingsAccount();
        //Program to super Type
        Account account = new SavingsAccount();
    }
}
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
											Polymorphism

Polymorphism is the implementation of "Typing" theory.

Polymorphism means many forms.

In java 
		 	"One Object behaving in multiple ways using a single interface or reference"

Types of Polymorphism:

1.Compile time Polymorphism
2.Runtime polymorphism.

1.Compile time Polymorphism
	It is compile time decision for the reference variable of method binding.

class A{
	add
}

A a = new A()
a.add() - compiler is very clear what to do

A class can have similar  more methods  - overloading

overloading:
1.Different number of parameters
2.Different type of parameters

What you can overload?
1.methods
2.constructors

package com.tesco.oo.polymorphism.overloading;

public class Calculator {
    int add(int a, int b) {
        return a + b;
    }

    int add(int a, int b, int c) {
        return a + b + c;
    }

    int add(double a, int i, float b) {
        return (int) (a + i + b);
    }
}
package com.tesco.oo.polymorphism.overloading;

public class CalculatorMain {
    public static void main(String[] args) {
        Calculator calculator = new Calculator();
        System.out.println(calculator.add(19, 2));
        System.out.println(calculator.add(19, 2,89));
        System.out.println(calculator.add(12.8, 2,9.0f));
    }
}
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
										constructors and overloading
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

constructors are special methods used to initialize the state

state:
 with in class directly  -during object creation
 outside class using setters - after object creation
 using constructors - during object creation.

constructor syntax:
  
public class Customer{
	
	public | private | no keyword Customer(){} -  default constructor - no arg constructor
	public | private | no keyword Customer(int id,String name){} -  two arg constructor - overloaded


}
package com.tesco.oo.polymorphism.overloading;

public class Customer {
    private int id;
    private String name;
    private String city;
    private double creditLimit;

    //constructors
    public Customer(){

    }
    public Customer(int id, String name, String city, double creditLimit) {
        this.id = id;
        this.name = name;
        this.city = city;
        this.creditLimit = creditLimit;
    }

    public Customer(int id, String name) {
        this.id = id;
        this.name = name;
    }

    public Customer(int id, String name, String city) {
        this.id = id;
        this.name = name;
        this.city = city;
    }

    public Customer(String name, double creditLimit) {
        this.name = name;
        this.creditLimit = creditLimit;
    }

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getCity() {
        return city;
    }

    public void setCity(String city) {
        this.city = city;
    }

    public double getCreditLimit() {
        return creditLimit;
    }

    public void setCreditLimit(double creditLimit) {
        this.creditLimit = creditLimit;
    }
}
package com.tesco.oo.polymorphism.overloading;

public class ConstructorOverloading {
    public static void main(String[] args) {
        Customer customer1 = new Customer();
        Customer customer2 = new Customer(1, "Test");
        Customer customer3 = new Customer(1, "Test", "City");
        Customer customer4 = new Customer(1, "test", "city", 45);


        System.out.println(customer3.getCity() + customer3.getName());
    }
}
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
									Runtime Polymorphism  - Method overriding
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

How to re use methods across the inheritance family?
	
Parent class has one method
the same can be overridden in derived class with different implementation

Rules:
 1.method name,return type,arg type must be same
  2.access modifier may different


package com.tesco.oo.runtimepoly.overriding;

public class Animal {
    public void eat(){
        System.out.println("Animal eats");
    }
}
package com.tesco.oo.runtimepoly.overriding;

public class Dog extends Animal {
	
}

public class OverdingSimple {
    public static void main(String[] args) {
        Dog dog = new Dog();
        dog.eat();
    }
}
how this works, because during compile time, the compiler copies the base class code into derived class

Animal.class
public class Animal {
    public void eat(){
        System.out.println("Animal eats");
    }
}
package com.tesco.oo.runtimepoly.overriding;

Dog.class
public class Dog extends Animal {
     public void eat(){
	   super.eat()        
     }
}
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

What if i write my own /my version of eat method?
package com.tesco.oo.runtimepoly.overriding;

public class Dog extends Animal {
    @Override
    public void eat() {
        super.eat();
    }
}

ourversion:
package com.tesco.oo.runtimepoly.overriding;

public class Dog extends Animal {
    @Override
    public void eat() {
        System.out.println("Dog eats!");
    }
}
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
								Program to Super Type and overriding , Reference Conversion
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&


 Animal animal = new Dog();
 animal.eat();

What would be the output?
Dog eats!
How?

 Animal animal = new Dog();
 animal.eat();
  
In this code, eat method is mapped/verified against "type" during compile time.
	here type is Animal, 
		eat method is declared 

During runtime , the runtime always looks the object implementation i mean right of the code

						   "During compile time, left side, during runtime right side"


  Animal animal = new Dog();
        animal.eat();
        //Cannot resolve method 'bark' in 'Animal'
       // animal.bark();

		here bark is not available in the "Animal" Type, so we cant call bark method using "Animal" Type, what if i want to call 
							  				Solution is
									 "Reference type Conversion"

Reference type conversion is other wise called as "down casting"

Synatx:
		SubType variable = (SubType) variableOfSuperType
   		
	        Dog tmpDog = (Dog) animal;
                tmpDog.bark();

&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
										Static variables and methods
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

A static variable  are variables which are called with help of class name.

1.Belongs to the class,Not to Objects
2.is shared among all objects
3.created only once in memory
4.Loaded when the class is loaded 


package com.tesco.oo.staticvariables;

public class Utility {
    public static String COMPANY_NAME = "Tesco";

    public static void getInfo() {
        System.out.println("Info");
    }
}
package com.tesco.oo.staticvariables;

public class StaticMain {
    public static void main(String[] args) {
        System.out.println(Utility.COMPANY_NAME);
        Utility.getInfo();
    }
}

Why main method is marked static?
  public static void main(String[] args) {
        System.out.println(Utility.COMPANY_NAME);
        Utility.getInfo();
    }
java runtime supplies entry class , that class will call main method directly.

JVMEntry
	 call main method
		StaticMain.main()

&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
										 final  - constants

if you want declare constant, you can use final
	int a =10;
	 a=30 // reinitialized variable
	
	what if i don't want to reinitialize  the a only one time i have initialize
	final variables

    final float PI = 3.14f;
        System.out.println(PI);
        PI =90.99f;
************************************************************************************************************************************************************
								 static variables and final

as per coding standard , static variables must be marked final, so those variables will not be reinitialized 
package com.tesco.oo.staticvariables;

public class Utility {
    public  static final String COMPANY_NAME = "Tesco";
}
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
								methods and final keyword

if any method is marked final, cant be overridden
package com.tesco.oo.finalkeyword;

public class Account {
    public final String getName(){
        return  "Subramnaian";
    }
}
package com.tesco.oo.finalkeyword;

public class SavingsAccount extends Account {
    @Override
    public String getName() {
        return "Subramanian Murugan";
    }
}
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
										final and classes
if you declare class as final, the class cant be extended (inherited)

public final class A{}

public class B  extends A {} - This is compile time error

&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
											Java in built classes and packages
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
Package java.lang

Provides classes that are fundamental to the design of the Java programming language. 
The most important classes are Object, which is the root of the class hierarchy, and Class, instances of which represent classes at run time.

class A {}

 Does A has Parent class?
   no parent 

class B {}

class C extends B {}

 Does C has Parent class?
   Yes ,there is  parent class called "B"


class A {}

 Does A has Parent class?
   yes, according to java, every "java class has parent" -  java.lang.Object

public class Object{}

public class A extends Object {

}

Methods of Object class , will be available automatically into all java classes.

Class Object is the root of the class hierarchy. Every class has Object as a superclass. All objects, including arrays, implement the methods of this class.

common methods of java.lang.Object:
................................................................

1.toString
package com.tesco.oo.lang.object;

public class Greeter {
    public String sayHello() {
        return "Hello";
    }
}
package com.tesco.oo.lang.object;

public class LangMain {
    public static void main(String[] args) {
        Greeter greeter = new Greeter();
        System.out.println(greeter.sayHello());
        System.out.println(greeter.toString());
    }
}
Now toString implementation of object class is invoked
com.tesco.oo.lang.object.Greeter@1b28cdfa

Can i override toString and give meaning full implementation

Yes
package com.tesco.oo.lang.object;

public class Greeter {
    public String sayHello() {
        return "Hello";
    }

    @Override
    public String toString() {
        return "Greeter Class";
    }
}
output:
Hello
Greeter Class
package com.tesco.oo.lang.object;

public class LangMain {
    public static void main(String[] args) {
        Greeter greeter = new Greeter();
        System.out.println(greeter.sayHello());
        System.out.println(greeter.toString());

        //Program to Super type
        Object hello = new Greeter();
        System.out.println(hello.toString());
        Greeter tmpGreeter = (Greeter) hello;
        System.out.println(tmpGreeter.sayHello());
    }
}
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
										hashCode

hashcode is unique number generated by jvm to identify each objects uniquely inside jvm.


public class HashCodeMain {
    public static void main(String[] args) {
        Greeter greeter = new Greeter();
        System.out.println(greeter.hashCode());
    }
}

overriding hash code:
....................................
package com.tesco.oo.lang.object;

public class Greeter {
    public String sayHello() {
        return "Hello";
    }

    @Override
    public String toString() {
        return "Greeter Class";
    }

    @Override
    public int hashCode() {
        return 34343434 * 34;
    }
}
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
										 class Object
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

Source code 
Hello.java

public class Hello {}

Compilation - Hello.class-------load into jvm------>JVM prepares the "class Object from the Hello.class" (meta object)-------->Hello instance created.
package com.tesco.oo.lang.object;

public class ClassObject {
    public static void main(String[] args) {
        Greeter greeter = new Greeter();
        System.out.println(greeter.getClass().getName());
    }
}
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
									Wrapper classes
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

java has primitive data types like byte,short,int,float,double,char....

What if i want the same primitive types as objects -  Wrapper classes .........

Wrapper classes are object representation of primitive, which is part of the  "java.lang" package


byte --------java.lang.Byte
short ------java.lang.Short
int --------java.lang.Integer
long------java.lang.Long
float -----java.lang.Float
double -- java.lang.Double
char ----java.lang.Char
boolean -java.lang.Boolean...

package com.tesco.oo.lang.object.wrapperclasses;

public class WrapperDemos {
    public static void main(String[] args) {
//        Integer i = new Integer(100);
        //i is reference variable, Integer is Reference type
        //100 is primitve value, how this 100 is converted into Wrapper
        //Boxing
        Integer i = 100;
        System.out.println(i.longValue());

        Integer a = 100;
        //Reference to Primitive: Unboxing
        int b = a;
    }
}
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
										Strings

Strings are object - java.lang.String

String object has lot of methods for string processing.		
		
package com.tesco.oo.lang.object.wrapperclasses;

public class StringDemo {
    public static void main(String[] args) {
        String str = "Hello";
        System.out.println(str.toLowerCase());
        System.out.println(str.toUpperCase());
        System.out.println(str.chars().max().getAsInt());

        //how to equals two strings
        String name = "Subramnaian";
        String anotherName = "Subramanian";
        if (name == anotherName) {
            System.out.println("two Strings are equal");
        } else {
            System.out.println("two Strings are equal");
        }
        if (name.equalsIgnoreCase(anotherName)) {
            System.out.println("two Strings are equal");
        } else {
            System.out.println("two Strings are equal");
        }

    }
}
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
									java.lang.Object - equals methods
************************************************************************************************************************************************************
Comparing objects for equality 

int a  =10
int b = 10
boolean b = a ==b
 result is true

package com.tesco.oo.lang.object.referenceequals;

public class Employee {
    private int id;
    private String name;

    public Employee() {
    }

    public Employee(int id, String name) {
        this.id = id;
        this.name = name;
    }

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}

package com.tesco.oo.lang.object.referenceequals;

public class EmployeeEqualsMain {
    public static void main(String[] args) {
        Employee empOne = new Employee(1, "Subramanian");
        Employee empTwo = new Employee(1, "Subramanian");
        //equal operator
        if (empOne == empTwo) {
            System.out.println("Employees are equal");
        } else {
            System.out.println("Employees are not equal");
        }
    }
}

Result:
Employees are not equal

	Why: Our Objective or observation that two employee objects having same data, but actually equal to operator is not giving right result

equal  to operator:
				never compares the data of objects rather it compares memory location of those objects

package com.tesco.oo.lang.object.referenceequals;

public class EmployeeEqualsMain {
    public static void main(String[] args) {
        Employee empOne = new Employee(1, "Subramanian");
        Employee empTwo = new Employee(1, "Subramanian");
        //equal operator
//        if (empOne == empTwo) {
//            System.out.println("Employees are equal");
//        } else {
//            System.out.println("Employees are not equal");
//        }
        //
        Employee empThree = empOne;

        if (empOne == empThree) {
            System.out.println("Employees are equal");
        } else {
            System.out.println("Employees are not equal");
        }
    }
}
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
										How to compare the content of Objects

equals method of java.lang.Object


  if (empOne.equals(empTwo)) {
            System.out.println("Employees are equal");
        } else {
            System.out.println("Employees are not equal");
        }
Employees are not equal 
   	because java.lang.equals method always returns false, because they dont know on what basis the objects are compared

package com.tesco.oo.lang.object.referenceequals;

public class Employee {
    private int id;
    private String name;

    public Employee() {
    }

    public Employee(int id, String name) {
        this.id = id;
        this.name = name;
    }

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    @Override
    public boolean equals(Object obj) {
        Employee tmpEmp = (Employee) obj;
        return tmpEmp.getId() == this.getId();
    }
}
package com.tesco.oo.lang.object.referenceequals;

public class EmployeeEqualsMain {
    public static void main(String[] args) {
        Employee empOne = new Employee(1, "Subramanian");
        Employee empTwo = new Employee(2, "Subramanian");
        //equal operator
//        if (empOne == empTwo) {
//            System.out.println("Employees are equal");
//        } else {
//            System.out.println("Employees are not equal");
//        }
        //
//        Employee empThree = empOne;
//
//        if (empOne == empThree) {
//            System.out.println("Employees are equal");
//        } else {
//            System.out.println("Employees are not equal");
//        }

        if (empOne.equals(empTwo)) {
            System.out.println("Employees are equal");
        } else {
            System.out.println("Employees are not equal");
        }

    }
}
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
									Data Structures
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

Data structure is way of organizing and storing data so that it can be used efficiently.

Java implementation:
1.Core Data Structure
	Arrays, Strings (Collection of characters)
2.Advanced data structure
	Collections framework , it is advanced dynamic data structure


Array:
 ->Array is object - which is built in object
 ->It stores fixed size values
->It stores same data type
->The values are stored and processed based on index, index starts 0.

Array can store primitives values and reference valules
syntax:

1.
type [] variableName=new type[size]

int[] nums = new int [5];

nums[0]=10

2.
 type[] variableName = {list of values};
 int[] nums = {1,2,3,4,5,6}
 
primitive types:

package com.tesco.datastructure.arrays;

public class SimpleArray {
    public static void main(String[] args) {
        int[] nums = new int[3];
        nums[0] = 10;
        nums[1] = 20;
        nums[2] = 30;
        //iterate
        for (int i = 0; i < nums.length; i++) {
            System.out.println(nums[i]);
        }
        double[] prices = {
                13.45, 10.9, 45.8, 90.8
        };
        for (int i = 0; i < prices.length; i++) {
            System.out.println(prices[i]);
        }
    }
}

Reference types:
............................
package com.tesco.oo.lang.object.referenceequals;

public class Employee {
    private int id;
    private String name;

    public Employee() {
    }

    public Employee(int id, String name) {
        this.id = id;
        this.name = name;
    }

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    @Override
    public boolean equals(Object obj) {
        Employee tmpEmp = (Employee) obj;
        return tmpEmp.getId() == this.getId();
    }
}
package com.tesco.datastructure.arrays;


public class ReferenceTypeArray {
    public static void main(String[] args) {
        Employee[] employees = {
                new Employee(1, "Subramanian"),
                new Employee(2, "John"),
                new Employee(3, "James"),
                new Employee(4, "Patrick")
        };
        //traditional for loop
        for (int i = 0; i < employees.length; i++) {
            Employee tempEmp = employees[i];
//            System.out.println(tempEmp.getId() + " " + tempEmp.getName());
            System.out.println(tempEmp);
        }
        //enchanced for loop
        for (Employee emp : employees) {
            System.out.println(emp);
        }
    }
}
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
								 Types of array

1.single dimensional array
2.multi dimensional array -2d,3d and irregular (jagged arrays)

2 Dimensional array:
   Stores the values into rows and columns

Store marks of 3 students in 3 subjects

package com.tesco.datastructure.arrays;

public class TwoDimensionalArray {
    public static void main(String[] args) {
        int[][] marks = {
                {86, 89, 90}, //student 1 =i
                {56, 89, 90}, // student 2=i
                {99, 97, 98},  // student 3=i
                {89, 90, 90}
        };
        //inner loop takes care of marks //columns
        //outer loop takes care of students // row
        //for each student, marks will be printed
        for (int i = 0; i < marks.length; i++) {
            System.out.println("Student " + (i + 1) + ":");
            for (int j = 0; j < marks[i].length; j++) {
                System.out.println(" " + marks[i][j] + " ");
            }
        }
        int rowNumber = 1;
        for (int[] row : marks) {
            System.out.println("Student : " + rowNumber + " :");
            for (int value : row) {
                System.out.println(value + " ");
            }
            System.out.println();
            rowNumber++;
        }
    }
}
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&











